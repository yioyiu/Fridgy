name: iOS Build(Xcode)

on:
  push:
    branches: [master, main]
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type (development/preview/production)'
        required: false
        default: 'production'
        type: choice
        options:
          - development
          - preview
          - production

permissions:
  contents: read

jobs:
  build:
    name: Build iOS App with Xcode
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: |
          echo "Installing dependencies..."
          # Try npm ci first, fallback to npm install if it fails
          npm ci || {
            echo "npm ci failed (package.json and package-lock.json out of sync)"
            echo "Falling back to npm install..."
            npm install
          }

      - name: Setup Expo CLI
        run: npm install -g @expo/cli@latest

      - name: Backup ExportOptions.plist
        run: |
          if [ -f ios/ExportOptions.plist ]; then
            mkdir -p .backup
            cp ios/ExportOptions.plist .backup/ExportOptions.plist
            echo "ExportOptions.plist backed up"
          else
            echo "::warning::ExportOptions.plist not found before prebuild"
          fi

      - name: Prebuild iOS project
        run: npx expo prebuild --platform ios --clean

      - name: Restore ExportOptions.plist
        run: |
          if [ -f .backup/ExportOptions.plist ]; then
            cp .backup/ExportOptions.plist ios/ExportOptions.plist
            echo "ExportOptions.plist restored"
          else
            echo "::error::ExportOptions.plist backup not found"
            exit 1
          fi

      - name: Cache CocoaPods
        uses: actions/cache@v4
        with:
          path: |
            ios/Pods
            ~/Library/Caches/CocoaPods
          key: ${{ runner.os }}-pods-${{ hashFiles('ios/Podfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-pods-

      - name: Install CocoaPods dependencies
        run: |
          cd ios
          pod install --repo-update
          cd ..

      - name: Disable code signing for Pods
        run: |
          # 修改 Podfile，添加 post_install hook 来禁用 Pods 的代码签名
          # 这样可以避免在 [CP] Embed Pods Frameworks 步骤中卡住
          cd ios
          if [ -f Podfile ]; then
            echo "Checking Podfile for code signing configuration..."
            # 检查是否已经禁用了代码签名
            if grep -q 'CODE_SIGNING_ALLOWED.*NO' Podfile; then
              echo "✅ Code signing already disabled for Pods"
            else
              echo "Adding post_install hook to disable code signing for Pods..."
              # 使用 Ruby 脚本来安全地修改 Podfile
              ruby -e "
              podfile_path = 'Podfile'
              content = File.read(podfile_path)
              
              if content.include?('post_install do')
                unless content.include?('CODE_SIGNING_ALLOWED')
                  pattern = /(post_install do \|installer\|.*?)(\nend)/
                  replacement = \"\\\\1\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings[\\\"CODE_SIGNING_ALLOWED\\\"] = \\\"NO\\\"\n    end\n  end\n\\\\2\"
                  content = content.sub(pattern, replacement)
                  File.write(podfile_path, content)
                  puts '✅ Added CODE_SIGNING_ALLOWED = NO to existing post_install hook'
                else
                  puts '✅ CODE_SIGNING_ALLOWED already configured'
                end
              else
                post_install_hook = \"\n\npost_install do |installer|\n  installer.pods_project.targets.each do |target|\n    target.build_configurations.each do |config|\n      config.build_settings[\\\"CODE_SIGNING_ALLOWED\\\"] = \\\"NO\\\"\n    end\n  end\nend\n\"
                File.open(podfile_path, 'a') { |f| f.write(post_install_hook) }
                puts '✅ Added new post_install hook with CODE_SIGNING_ALLOWED = NO'
              end
              "
              echo "Podfile updated. Last 15 lines:"
              tail -15 Podfile
              # 重新运行 pod install 以应用更改
              echo "Running pod install to apply changes..."
              pod install
            fi
          else
            echo "::warning::Podfile not found, skipping code signing configuration"
          fi
          cd ..

      - name: Bump iOS build number
        run: |
          if ! npm run bump:ios-build; then
            echo "::warning::Failed to bump iOS build number, continuing with existing build number"
          fi

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Get Team ID from ExportOptions.plist
        id: get_team_id
        run: |
          # 检查文件是否存在
          if [ ! -f ios/ExportOptions.plist ]; then
            echo "::error::ExportOptions.plist not found at ios/ExportOptions.plist"
            echo "Please ensure the file is committed to Git"
            exit 1
          fi
          
          # 使用 plutil 提取 Team ID（静默错误）
          TEAM_ID=""
          if command -v plutil &> /dev/null; then
            TEAM_ID=$(plutil -extract teamID raw ios/ExportOptions.plist 2>&1)
            # 检查是否是错误信息
            if [[ "$TEAM_ID" == *"Error"* ]] || [[ "$TEAM_ID" == *"error"* ]]; then
              TEAM_ID=""
            fi
          fi
          
          # 如果 plutil 失败，使用 grep + sed 备用方法
          if [ -z "$TEAM_ID" ]; then
            TEAM_ID=$(grep -A 1 '<key>teamID</key>' ios/ExportOptions.plist | grep '<string>' | sed -E 's/.*<string>([^<]*)<\/string>.*/\1/' | tr -d '[:space:]')
          fi
          
          # 验证 Team ID 格式（应该是 10 个字符的字母数字组合）
          if [ -z "$TEAM_ID" ] || [ "$TEAM_ID" = "YOUR_TEAM_ID" ] || [ ${#TEAM_ID} -lt 8 ]; then
            echo "::error::Team ID not found or invalid in ios/ExportOptions.plist"
            echo "Extracted value: '$TEAM_ID'"
            echo "File content:"
            cat ios/ExportOptions.plist
            exit 1
          fi
          
          echo "team_id=$TEAM_ID" >> $GITHUB_OUTPUT
          echo "Team ID extracted: $TEAM_ID"

      - name: Install fastlane
        run: |
          sudo gem install fastlane -NV
          fastlane --version

      - name: Setup fastlane match
        env:
          # App Store Connect API Key（推荐方式，无需 2FA）
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}
          # 备用方式：Apple ID + 密码（需要 2FA）
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          FASTLANE_SESSION: ${{ secrets.FASTLANE_SESSION }}
          FASTLANE_USER: ${{ secrets.APPLE_ID }}
          FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
        run: |
          # fastlane match 会自动管理证书和 provisioning profiles
          # 优先使用 App Store Connect API Key（无需 2FA，推荐）
          # 如果没有配置 API Key，则回退到 Apple ID + 密码方式
          
          if [ -z "$MATCH_PASSWORD" ]; then
            echo "::error::MATCH_PASSWORD is required for fastlane match"
            echo "::error::Please configure MATCH_PASSWORD secret (used to encrypt certificates)"
            exit 1
          fi
          
          # 检查是否使用 App Store Connect API Key
          USE_API_KEY=0
          API_KEY_PATH=""
          if [ -n "$APP_STORE_CONNECT_API_KEY_ID" ] && [ -n "$APP_STORE_CONNECT_API_ISSUER_ID" ] && [ -n "$APP_STORE_CONNECT_API_KEY_CONTENT" ]; then
            USE_API_KEY=1
            echo "✅ 使用 App Store Connect API Key 认证（无需 2FA）"
            echo "API Key ID: $APP_STORE_CONNECT_API_KEY_ID"
            echo "Issuer ID: $APP_STORE_CONNECT_API_ISSUER_ID"
            
            # fastlane 期望 API Key 是一个 JSON 文件，而不是 .p8 文件
            # 创建 JSON 格式的 API Key 文件
            API_KEY_DIR="$HOME/.appstoreconnect/private_keys"
            mkdir -p "$API_KEY_DIR"
            API_KEY_PATH="$API_KEY_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.json"
            
            # 使用 Python 创建 JSON 文件，确保正确转义
            # fastlane 期望的 JSON 格式：
            # {
            #   "key_id": "...",
            #   "issuer_id": "...",
            #   "key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
            #   "duration": 1200,
            #   "in_house": false
            # }
            # 使用 Python 创建 JSON 文件
            # 将私钥内容写入临时文件，然后使用 Python 读取并创建 JSON
            TEMP_KEY_FILE=$(mktemp)
            echo "$APP_STORE_CONNECT_API_KEY_CONTENT" > "$TEMP_KEY_FILE"
            
            # 创建 Python 脚本临时文件（使用 printf 避免 heredoc 缩进问题）
            PYTHON_SCRIPT=$(mktemp)
            printf 'import json\nimport sys\n\ntemp_key_file = sys.argv[1]\nkey_id = sys.argv[2]\nissuer_id = sys.argv[3]\noutput_file = sys.argv[4]\n\nwith open(temp_key_file, "r") as f:\n    private_key_content = f.read()\n\napi_key_data = {\n    "key_id": key_id,\n    "issuer_id": issuer_id,\n    "key": private_key_content,\n    "duration": 1200,\n    "in_house": False\n}\n\nwith open(output_file, "w") as f:\n    json.dump(api_key_data, f, indent=2)\n' > "$PYTHON_SCRIPT"
            
            # 执行 Python 脚本
            python3 "$PYTHON_SCRIPT" "$TEMP_KEY_FILE" "$APP_STORE_CONNECT_API_KEY_ID" "$APP_STORE_CONNECT_API_ISSUER_ID" "$API_KEY_PATH"
            
            # 清理临时文件
            rm -f "$TEMP_KEY_FILE" "$PYTHON_SCRIPT"
            chmod 600 "$API_KEY_PATH"
            echo "✅ API Key JSON 文件已创建: $API_KEY_PATH"
            
            # 验证 JSON 格式
            if command -v python3 &> /dev/null; then
              if python3 -m json.tool "$API_KEY_PATH" > /dev/null 2>&1; then
                echo "✅ JSON 格式验证成功"
              else
                echo "::error::JSON 格式验证失败"
                exit 1
              fi
            fi
          elif [ -n "$APPLE_ID" ] && [ -n "$APPLE_PASSWORD" ]; then
            echo "⚠️  使用 Apple ID + 密码认证（需要 2FA，建议使用 API Key）"
            echo "Apple ID: $APPLE_ID"
          else
            echo "::error::需要配置认证方式："
            echo "::error::方式 1（推荐）：配置 App Store Connect API Key"
            echo "::error::  - APPSTORE_API_KEY_ID"
            echo "::error::  - APPSTORE_ISSUER_ID"
            echo "::error::  - APPSTORE_API_PRIVATE_KEY"
            echo "::error::方式 2：配置 Apple ID + 密码（需要 2FA）"
            echo "::error::  - APPLE_ID"
            echo "::error::  - APPLE_PASSWORD"
            echo "::error::  - FASTLANE_SESSION（用于绕过 2FA）"
            exit 1
          fi
          
          # 创建 fastlane 目录
          mkdir -p fastlane
          
          # 确定 git_url
          GIT_URL="${{ secrets.MATCH_GIT_URL }}"
          if [ -z "$GIT_URL" ]; then
            GIT_URL="https://github.com/yioyiu/fridgy-certificates.git"
          fi
          
          echo "Using git_url: $GIT_URL"
          
          # 更新 Matchfile（覆盖以确保使用正确的配置）
          {
            echo "git_url(\"$GIT_URL\")"
            echo "storage_mode(\"git\")"
            echo "type(\"appstore\")"
            echo "app_identifier(\"com.fridgy.app\")"
            if [ $USE_API_KEY -eq 1 ]; then
              # API Key 方式：在 Matchfile 中指定绝对路径
              echo "team_id(\"${{ steps.get_team_id.outputs.team_id }}\")"
              echo "api_key_path(\"$API_KEY_PATH\")"
            else
              # Apple ID + 密码方式
              echo "username(\"$APPLE_ID\")"
              echo "team_id(\"${{ steps.get_team_id.outputs.team_id }}\")"
            fi
          } > fastlane/Matchfile
          
          # 如果使用 API Key，将路径保存到环境变量供后续步骤使用
          if [ $USE_API_KEY -eq 1 ]; then
            echo "API_KEY_PATH=$API_KEY_PATH" >> $GITHUB_ENV
            echo "APP_STORE_CONNECT_API_KEY_PATH=$API_KEY_PATH" >> $GITHUB_ENV
          fi
          
          echo "Matchfile created:"
          cat fastlane/Matchfile
          
          # 验证 Matchfile 格式
          if ! grep -q "git_url" fastlane/Matchfile; then
            echo "::error::Failed to create Matchfile with git_url"
            exit 1
          fi

      - name: Run fastlane match to sync certificates
        id: run_fastlane_match
        env:
          # App Store Connect API Key（推荐方式，无需 2FA）
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}
          # 备用方式：Apple ID + 密码（需要 2FA）
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          FASTLANE_SESSION: ${{ secrets.FASTLANE_SESSION }}
          FASTLANE_USER: ${{ secrets.APPLE_ID }}
          FASTLANE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          MATCH_GIT_BASIC_AUTHORIZATION: ${{ secrets.MATCH_GIT_BASIC_AUTHORIZATION }}
        run: |
          # API Key JSON 文件已在 "Setup fastlane match" 步骤中创建
          # 如果使用 App Store Connect API Key，验证 JSON 文件是否存在
          if [ -n "$APP_STORE_CONNECT_API_KEY_ID" ] && [ -n "$APP_STORE_CONNECT_API_ISSUER_ID" ]; then
            API_KEY_DIR="$HOME/.appstoreconnect/private_keys"
            API_KEY_PATH="$API_KEY_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.json"
            
            if [ -f "$API_KEY_PATH" ]; then
              echo "✅ API Key JSON 文件已存在: $API_KEY_PATH"
              # 确保环境变量正确设置
              export APP_STORE_CONNECT_API_KEY_PATH="$API_KEY_PATH"
              echo "APP_STORE_CONNECT_API_KEY_PATH=$API_KEY_PATH" >> $GITHUB_ENV
            else
              echo "::error::API Key JSON 文件不存在: $API_KEY_PATH"
              echo "::error::请确保 'Setup fastlane match' 步骤已成功创建 JSON 文件"
              exit 1
            fi
          fi
          
          # 清理环境变量（去除首尾空格和换行符）
          # fastlane match 期望 base64 编码的 username:token
          ORIGINAL_AUTH=""
          if [ -n "$MATCH_GIT_BASIC_AUTHORIZATION" ]; then
            ORIGINAL_AUTH=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # 检查是否已经是 base64 编码（base64 字符串通常不包含冒号，除非是编码后的结果）
            # 如果包含冒号且看起来像 username:token 格式，则进行 base64 编码
            if [[ "$ORIGINAL_AUTH" == *":"* ]] && [[ "$ORIGINAL_AUTH" != *"==" ]] && [[ "$ORIGINAL_AUTH" != *"=" ]]; then
              # 看起来是 username:token 格式，需要 base64 编码
              echo "检测到 username:token 格式，正在转换为 base64..."
              export MATCH_GIT_BASIC_AUTHORIZATION=$(echo -n "$ORIGINAL_AUTH" | base64)
              echo "已转换为 base64 格式"
            else
              # 可能已经是 base64 编码，或者只是 token，直接使用
              export MATCH_GIT_BASIC_AUTHORIZATION="$ORIGINAL_AUTH"
              echo "使用原始格式（可能是 base64 或仅 token）"
            fi
          fi
          
          # 运行 fastlane match 来同步证书和 profiles
          # 如果是第一次运行，match 会自动创建证书和 profiles
          # 如果证书已存在，match 会下载并使用它们
          
          echo "Current directory: $(pwd)"
          echo "Matchfile location: fastlane/Matchfile"
          echo "Matchfile contents:"
          cat fastlane/Matchfile
          
          # 验证 MATCH_GIT_BASIC_AUTHORIZATION 格式
          # 注意：fastlane match 期望 base64 编码的 username:token
          # 但我们也支持明文 username:token 格式（会自动转换）
          if [ -n "$MATCH_GIT_BASIC_AUTHORIZATION" ]; then
            # 检查是否是 base64 格式（尝试解码验证）
            if echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 -d > /dev/null 2>&1; then
              DECODED=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 -d 2>/dev/null)
              if [[ "$DECODED" == *":"* ]]; then
                AUTH_USER=$(echo "$DECODED" | cut -d: -f1)
                echo "MATCH_GIT_BASIC_AUTHORIZATION 是 base64 编码格式"
                echo "解码后的用户名: $AUTH_USER"
              else
                echo "::warning::MATCH_GIT_BASIC_AUTHORIZATION 是 base64，但解码后格式不正确"
              fi
            elif [[ -n "$ORIGINAL_AUTH" ]] && [[ "$ORIGINAL_AUTH" == *":"* ]]; then
              # 明文 username:token 格式（会在上面转换为 base64）
              AUTH_USER=$(echo "$ORIGINAL_AUTH" | cut -d: -f1)
              AUTH_TOKEN_PREFIX=$(echo "$ORIGINAL_AUTH" | cut -d: -f2 | cut -c1-4)
              echo "MATCH_GIT_BASIC_AUTHORIZATION 是明文格式（已转换为 base64）"
              echo "原始用户名: $AUTH_USER"
              echo "Token 前缀: $AUTH_TOKEN_PREFIX..."
            else
              echo "::warning::MATCH_GIT_BASIC_AUTHORIZATION 格式未知，可能是仅 token 格式"
              echo "::warning::建议使用 username:token 格式"
            fi
          else
            echo "::warning::MATCH_GIT_BASIC_AUTHORIZATION 未设置"
            echo "::warning::如果使用私有仓库，需要配置此 secret"
            echo "::warning::格式：username:token（例如：yioyiu:ghp_xxxxx）"
          fi
          
          # 确保 ios/fastlane 目录存在，并复制 Matchfile 到正确位置
          mkdir -p ios/fastlane
          cp fastlane/Matchfile ios/fastlane/Matchfile
          echo "Matchfile copied to ios/fastlane/Matchfile"
          cat ios/fastlane/Matchfile
          
          # 进入 ios 目录运行 match
          cd ios
          
          # 显示环境变量状态（不显示敏感信息）
          if [ -n "$MATCH_GIT_BASIC_AUTHORIZATION" ]; then
            if [ -n "$ORIGINAL_AUTH" ] && [[ "$ORIGINAL_AUTH" == *":"* ]]; then
              AUTH_PREFIX=$(echo "$ORIGINAL_AUTH" | cut -d: -f1)
              echo "MATCH_GIT_BASIC_AUTHORIZATION 已设置（用户名: $AUTH_PREFIX，已转换为 base64）"
            else
              echo "MATCH_GIT_BASIC_AUTHORIZATION 已设置（base64 格式）"
            fi
          else
            echo "::warning::MATCH_GIT_BASIC_AUTHORIZATION 未设置"
          fi
          
          if [ -n "$MATCH_PASSWORD" ]; then
            echo "MATCH_PASSWORD 已设置"
          else
            echo "::error::MATCH_PASSWORD 未设置"
            exit 1
          fi
          
          # 测试 Git 仓库访问（诊断 HTTP 400 问题）
          if [ -n "$MATCH_GIT_BASIC_AUTHORIZATION" ] && [ -n "$ORIGINAL_AUTH" ]; then
            GIT_URL=$(grep 'git_url' fastlane/Matchfile | sed 's/.*git_url("\(.*\)").*/\1/')
            echo "Testing Git repository access manually..."
            echo "Git URL: $GIT_URL"
            
            # 使用原始格式（username:token）进行测试
            # 因为 Git clone 需要明文格式，不是 base64
            if [[ "$ORIGINAL_AUTH" == *":"* ]]; then
              AUTH_USER=$(echo "$ORIGINAL_AUTH" | cut -d: -f1)
              AUTH_TOKEN=$(echo "$ORIGINAL_AUTH" | cut -d: -f2-)
            else
              # 如果是 base64，尝试解码
              DECODED_AUTH=$(echo "$ORIGINAL_AUTH" | base64 -d 2>/dev/null)
              if [[ "$DECODED_AUTH" == *":"* ]]; then
                AUTH_USER=$(echo "$DECODED_AUTH" | cut -d: -f1)
                AUTH_TOKEN=$(echo "$DECODED_AUTH" | cut -d: -f2-)
              else
                echo "::warning::无法解析认证信息，跳过手动测试"
                AUTH_USER=""
                AUTH_TOKEN=""
              fi
            fi
            
            # 移除 URL 末尾的斜杠（如果有）
            GIT_URL_CLEAN=$(echo "$GIT_URL" | sed 's|/$||')
            
            # 测试手动克隆（使用临时目录）
            if [ -n "$AUTH_USER" ] && [ -n "$AUTH_TOKEN" ]; then
              TEST_DIR=$(mktemp -d)
              echo "Testing clone to: $TEST_DIR"
              
              # 构建带认证的 URL
              if [[ "$GIT_URL_CLEAN" == https://* ]]; then
                # 对于 HTTPS URL，在 URL 中包含认证信息
                GIT_URL_WITH_AUTH=$(echo "$GIT_URL_CLEAN" | sed "s|https://|https://$AUTH_USER:$AUTH_TOKEN@|")
                echo "Attempting manual clone test..."
                if git clone "$GIT_URL_WITH_AUTH" "$TEST_DIR/test-repo" 2>&1 | head -20; then
                  echo "✅ 手动 Git 克隆测试成功"
                  rm -rf "$TEST_DIR"
                else
                  echo "❌ 手动 Git 克隆测试失败"
                  echo "这可能是以下原因之一："
                  echo "1. Token 已过期或无效"
                  echo "2. Token 权限不足（需要 repo 权限）"
                  echo "3. 仓库不存在或无法访问"
                  echo "4. URL 格式有问题"
                  rm -rf "$TEST_DIR"
                  # 不退出，让 fastlane match 尝试，看看是否有更详细的错误信息
                fi
              else
                echo "::warning::Git URL 不是 HTTPS 格式，跳过手动测试"
              fi
            fi
          fi
          
          echo "Running fastlane match appstore (readonly)..."
          
          # 设置详细日志以便诊断问题
          export FASTLANE_VERBOSE=1
          
          # 显示 API Key 相关环境变量状态（不显示敏感内容）
          echo "=========================================="
          echo "环境变量检查："
          echo "=========================================="
          if [ -n "$APP_STORE_CONNECT_API_KEY_ID" ]; then
            echo "✅ APP_STORE_CONNECT_API_KEY_ID 已设置: $APP_STORE_CONNECT_API_KEY_ID"
          else
            echo "⚠️  APP_STORE_CONNECT_API_KEY_ID 未设置"
          fi
          if [ -n "$APP_STORE_CONNECT_API_ISSUER_ID" ]; then
            echo "✅ APP_STORE_CONNECT_API_ISSUER_ID 已设置: $APP_STORE_CONNECT_API_ISSUER_ID"
          else
            echo "⚠️  APP_STORE_CONNECT_API_ISSUER_ID 未设置"
          fi
          if [ -n "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
            echo "✅ APP_STORE_CONNECT_API_KEY_PATH 已设置: $APP_STORE_CONNECT_API_KEY_PATH"
            if [ -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
              echo "✅ API Key 文件存在"
              ls -la "$APP_STORE_CONNECT_API_KEY_PATH"
            else
              echo "::error::API Key 文件不存在: $APP_STORE_CONNECT_API_KEY_PATH"
            fi
          else
            echo "⚠️  APP_STORE_CONNECT_API_KEY_PATH 未设置"
          fi
          echo "=========================================="
          echo "Running fastlane match appstore (readonly)..."
          echo "=========================================="
          
          # 如果使用 API Key，确保环境变量正确设置
          if [ -n "$APP_STORE_CONNECT_API_KEY_PATH" ] && [ -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
            echo "✅ 使用 API Key 认证"
            echo "API Key 路径: $APP_STORE_CONNECT_API_KEY_PATH"
            echo "API Key ID: $APP_STORE_CONNECT_API_KEY_ID"
            echo "Issuer ID: $APP_STORE_CONNECT_API_ISSUER_ID"
            
            # 验证 API Key JSON 文件格式
            if command -v python3 &> /dev/null; then
              if python3 -m json.tool "$APP_STORE_CONNECT_API_KEY_PATH" > /dev/null 2>&1; then
                echo "✅ API Key JSON 文件格式正确"
                # 验证 JSON 中包含必需的字段
                if python3 -c "import json; data = json.load(open('$APP_STORE_CONNECT_API_KEY_PATH')); assert 'key_id' in data and 'issuer_id' in data and 'key' in data" 2>/dev/null; then
                  echo "✅ API Key JSON 文件包含必需的字段"
                else
                  echo "::error::API Key JSON 文件缺少必需的字段（需要 key_id, issuer_id, key）"
                  exit 1
                fi
              else
                echo "::error::API Key JSON 文件格式不正确"
                exit 1
              fi
            else
              # 如果没有 python3，简单检查是否是 JSON（以 { 开头）
              if head -1 "$APP_STORE_CONNECT_API_KEY_PATH" | grep -q "^[[:space:]]*{"; then
                echo "✅ API Key 文件看起来是 JSON 格式"
              else
                echo "::warning::无法验证 JSON 格式（python3 不可用），继续尝试..."
              fi
            fi
          else
            echo "⚠️  未检测到 API Key，将使用 Apple ID + 密码方式"
          fi
          
          fastlane match appstore --readonly 2>&1 | tee /tmp/match-output.log
          MATCH_READONLY_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $MATCH_READONLY_EXIT_CODE -ne 0 ]; then
            echo "::warning::fastlane match readonly failed (exit code: $MATCH_READONLY_EXIT_CODE)"
            echo "=========================================="
            echo "完整错误日志："
            echo "=========================================="
            cat /tmp/match-output.log
            echo "=========================================="
            
            # 检查是否是 API Key 认证问题（JSON 解析错误表示 API Key 文件格式问题）
            if grep -qi "JSON::ParserError\|unexpected token\|parse.*error\|api.*key.*not.*found\|invalid.*api.*key" /tmp/match-output.log; then
              echo "::error::检测到 API Key 文件格式错误（JSON 解析失败）"
              echo "::error::请检查："
              echo "::error::1. APPSTORE_API_PRIVATE_KEY 内容是否完整（包括 -----BEGIN PRIVATE KEY----- 和 -----END PRIVATE KEY-----）"
              echo "::error::2. APPSTORE_API_PRIVATE_KEY 是否包含特殊字符导致 JSON 格式错误"
              echo "::error::3. 如果问题持续，请检查 workflow 日志中的 JSON 文件内容"
            elif grep -qi "unauthorized\|authentication.*failed\|401\|403" /tmp/match-output.log; then
              echo "::error::检测到 API Key 认证错误（权限问题）"
              echo "::error::请检查："
              echo "::error::1. APPSTORE_API_KEY_ID 是否正确"
              echo "::error::2. APPSTORE_ISSUER_ID 是否正确"
              echo "::error::3. API Key 权限是否至少为 'App Manager'（需要创建证书和 profiles）"
              echo "::error::4. API Key 是否已过期或被撤销"
            elif grep -qi "No code signing identity found.*readonly" /tmp/match-output.log; then
              echo "ℹ️  这是正常的：仓库中没有证书，需要创建（readonly 模式无法创建）"
              echo "ℹ️  将继续尝试创建模式..."
            fi
            
            # 检查是否是 Git 认证问题
            if grep -q "400\|401\|403" /tmp/match-output.log; then
              echo "::error::检测到 Git 认证错误（400/401/403）"
              echo "::error::请检查："
              echo "::error::1. MATCH_GIT_BASIC_AUTHORIZATION 格式是否正确（username:token）"
              echo "::error::2. Token 是否有效且未过期"
              echo "::error::3. Token 是否有 repo 权限"
              echo "::error::4. 仓库 URL 是否正确"
            fi
            
            # 检查是否是权限问题
            if grep -qi "permission\|forbidden\|access.*denied\|insufficient.*permission" /tmp/match-output.log; then
              echo "::error::检测到权限错误"
              echo "::error::API Key 权限可能不足，需要至少 'App Manager' 权限才能创建证书和 profiles"
            fi
            
            echo "=========================================="
            echo "尝试创建模式（强制更新以包含所有功能）..."
            echo "=========================================="
            echo "Running fastlane match appstore (create mode with force)..."
            # 再次确认环境变量
            if [ -n "$APP_STORE_CONNECT_API_KEY_PATH" ] && [ -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
              echo "✅ API Key 文件确认存在: $APP_STORE_CONNECT_API_KEY_PATH"
            fi
            # 使用 --force 强制重新创建 profile，确保包含所有功能（如 Push Notifications）
            # 注意：这需要确保在 Apple Developer Portal 中应用已启用 Push Notifications
            fastlane match appstore --force 2>&1 | tee /tmp/match-create.log
            MATCH_FORCE_EXIT_CODE=${PIPESTATUS[0]}
            
            if [ $MATCH_FORCE_EXIT_CODE -ne 0 ]; then
              echo "::error::fastlane match 创建模式也失败 (exit code: $MATCH_FORCE_EXIT_CODE)"
              echo "=========================================="
              echo "完整错误日志："
              echo "=========================================="
              cat /tmp/match-create.log
              echo "=========================================="
              
              # 检查是否是 API Key 文件格式问题（JSON 解析错误）
              if grep -qi "JSON::ParserError\|unexpected token\|parse.*error" /tmp/match-create.log; then
                echo "::error::检测到 API Key JSON 文件格式错误"
                echo "::error::请检查："
                echo "::error::1. APPSTORE_API_PRIVATE_KEY 内容是否完整（包括 -----BEGIN PRIVATE KEY----- 和 -----END PRIVATE KEY-----）"
                echo "::error::2. APPSTORE_API_PRIVATE_KEY 是否包含特殊字符导致 JSON 格式错误"
                echo "::error::3. 查看 workflow 日志中创建的 JSON 文件内容"
                exit 1
              fi
              
              # 检查是否是 API Key 认证问题（权限/认证失败）
              if grep -qi "unauthorized\|authentication.*failed\|401\|403" /tmp/match-create.log; then
                echo "::error::检测到 API Key 认证错误（权限问题）"
                echo "::error::请检查："
                echo "::error::1. APPSTORE_API_KEY_ID 是否正确"
                echo "::error::2. APPSTORE_ISSUER_ID 是否正确"
                echo "::error::3. API Key 权限是否至少为 'App Manager'"
                echo "::error::4. API Key 是否已过期或被撤销"
                exit 1
              fi
              
              # 检查是否是权限问题
              if grep -qi "permission\|forbidden\|access.*denied\|insufficient.*permission" /tmp/match-create.log; then
                echo "::error::检测到权限错误"
                echo "::error::API Key 权限可能不足，需要至少 'App Manager' 权限才能创建证书和 profiles"
                exit 1
              fi
              
              echo "::error::"
              echo "::error::如果 profile 不包含 Push Notifications，请确保："
              echo "::error::1. 在 Apple Developer Portal 中为 com.fridgy.app 启用了 Push Notifications"
              echo "::error::2. 访问: https://developer.apple.com/account/resources/identifiers/list"
              echo "::error::3. 找到 com.fridgy.app，确保 Push Notifications 已启用"
              echo "::error::4. 保存更改后，重新运行此 workflow"
              # 不退出，继续尝试查找 profile
            else
              echo "✅ fastlane match force mode succeeded"
            fi
          else
            echo "✅ fastlane match readonly succeeded"
            echo "ℹ️  Readonly mode only checks remote repository, does not download profiles"
            echo "ℹ️  Remote profiles may not include Push Notifications capability"
            echo "ℹ️  Will run with --force to ensure profiles include all required capabilities..."
            
            # readonly 模式成功只意味着远程仓库中有证书和 profiles
            # 但这些 profiles 可能不包含 Push Notifications 能力
            # 所以直接运行 --force 来强制重新创建包含所有能力的 profiles
            echo "=========================================="
            echo "Force recreating profiles with all capabilities..."
            echo "=========================================="
            # 再次确认环境变量
            if [ -n "$APP_STORE_CONNECT_API_KEY_PATH" ] && [ -f "$APP_STORE_CONNECT_API_KEY_PATH" ]; then
              echo "✅ API Key 文件确认存在: $APP_STORE_CONNECT_API_KEY_PATH"
            fi
            # 使用 --force 强制重新创建 profile，确保包含所有功能（如 Push Notifications）
            # 注意：这需要确保在 Apple Developer Portal 中应用已启用 Push Notifications
            fastlane match appstore --force 2>&1 | tee /tmp/match-force.log
            MATCH_FORCE_EXIT_CODE=${PIPESTATUS[0]}
            
            if [ $MATCH_FORCE_EXIT_CODE -ne 0 ]; then
              echo "::error::fastlane match force failed (exit code: $MATCH_FORCE_EXIT_CODE)"
              echo "=========================================="
              echo "完整错误日志："
              echo "=========================================="
              cat /tmp/match-force.log
              echo "=========================================="
              
              # 检查是否是 API Key 文件格式问题（JSON 解析错误）
              if grep -qi "JSON::ParserError\|unexpected token\|parse.*error" /tmp/match-force.log; then
                echo "::error::检测到 API Key JSON 文件格式错误"
                echo "::error::请检查："
                echo "::error::1. APPSTORE_API_PRIVATE_KEY 内容是否完整（包括 -----BEGIN PRIVATE KEY----- 和 -----END PRIVATE KEY-----）"
                echo "::error::2. APPSTORE_API_PRIVATE_KEY 是否包含特殊字符导致 JSON 格式错误"
                echo "::error::3. 查看 workflow 日志中创建的 JSON 文件内容"
                exit 1
              fi
              
              # 检查是否是 API Key 认证问题（权限/认证失败）
              if grep -qi "unauthorized\|authentication.*failed\|401\|403" /tmp/match-force.log; then
                echo "::error::检测到 API Key 认证错误（权限问题）"
                echo "::error::请检查："
                echo "::error::1. APPSTORE_API_KEY_ID 是否正确"
                echo "::error::2. APPSTORE_ISSUER_ID 是否正确"
                echo "::error::3. API Key 权限是否至少为 'App Manager'"
                echo "::error::4. API Key 是否已过期或被撤销"
                exit 1
              fi
              
              # 检查是否是权限问题
              if grep -qi "permission\|forbidden\|access.*denied\|insufficient.*permission" /tmp/match-force.log; then
                echo "::error::检测到权限错误"
                echo "::error::API Key 权限可能不足，需要至少 'App Manager' 权限才能创建证书和 profiles"
                exit 1
              fi
              
              echo "::error::"
              echo "::error::如果 profile 不包含 Push Notifications，请确保："
              echo "::error::1. 在 Apple Developer Portal 中为 com.fridgy.app 启用了 Push Notifications"
              echo "::error::2. 访问: https://developer.apple.com/account/resources/identifiers/list"
              echo "::error::3. 找到 com.fridgy.app，确保 Push Notifications 已启用"
              echo "::error::4. 保存更改后，重新运行此 workflow"
              exit 1
            else
              echo "✅ fastlane match force mode succeeded"
              echo "=========================================="
              echo "Checking fastlane match output for profile installation..."
              echo "=========================================="
              if [ -f /tmp/match-force.log ]; then
                echo "Fastlane match output (last 50 lines):"
                tail -50 /tmp/match-force.log
              fi
            fi
          fi
          
          echo "=========================================="
          echo "Fastlane match step completed"
          echo "=========================================="
          
          # 查找并保存 provisioning profile UUID
          # fastlane match 将 profiles 安装到 Xcode 使用的目录，而不是 MobileDevice 目录
          XCODE_PROFILE_DIR="$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles"
          MOBILEDEVICE_PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          
          echo "查找 provisioning profile..."
          echo "Xcode profile directory: $XCODE_PROFILE_DIR"
          echo "MobileDevice profile directory: $MOBILEDEVICE_PROFILE_DIR"
          
          # 检查 Xcode profile 目录（fastlane match 使用的目录）
          if [ ! -d "$XCODE_PROFILE_DIR" ]; then
            echo "::warning::Xcode Provisioning Profiles directory does not exist, creating it..."
            mkdir -p "$XCODE_PROFILE_DIR"
            chmod 755 "$XCODE_PROFILE_DIR"
          fi
          
          # 检查 MobileDevice profile 目录（xcodebuild 可能使用的目录）
          if [ ! -d "$MOBILEDEVICE_PROFILE_DIR" ]; then
            echo "::warning::MobileDevice Provisioning Profiles directory does not exist, creating it..."
            mkdir -p "$MOBILEDEVICE_PROFILE_DIR"
            chmod 755 "$MOBILEDEVICE_PROFILE_DIR"
          fi
          
          # 优先使用 Xcode profile 目录（fastlane match 安装的位置）
          PROFILE_DIR="$XCODE_PROFILE_DIR"
          
          echo "Using profile directory: $PROFILE_DIR"
          echo "Listing profiles in Xcode directory:"
          ls -la "$XCODE_PROFILE_DIR" 2>/dev/null | head -20 || echo "Directory is empty or not accessible"
          
          # 检查是否已经有 profiles 存在
          EXISTING_PROFILES=$(find "$PROFILE_DIR" -name "*.mobileprovision" -type f 2>/dev/null | wc -l | tr -d ' ')
          echo "Found $EXISTING_PROFILES existing profile(s) in directory"
          
          # 初始化变量
          SKIP_MANUAL_INSTALL=0
          FOUND_MATCHING_PROFILE=0
          
          # 如果已经有 profiles，检查是否包含 com.fridgy.app
          if [ "$EXISTING_PROFILES" -gt 0 ]; then
            echo "Checking if existing profiles match com.fridgy.app..."
            for profile in "$PROFILE_DIR"/*.mobileprovision; do
              if [ -f "$profile" ]; then
                TEMP_PLIST=$(mktemp)
                security cms -D -i "$profile" > "$TEMP_PLIST" 2>/dev/null
                if [ -s "$TEMP_PLIST" ]; then
                  if grep -q "com.fridgy.app" "$TEMP_PLIST" 2>/dev/null; then
                    echo "✅ Found matching profile for com.fridgy.app: $profile"
                    FOUND_MATCHING_PROFILE=1
                    rm -f "$TEMP_PLIST"
                    break
                  fi
                fi
                rm -f "$TEMP_PLIST"
              fi
            done
            
            if [ $FOUND_MATCHING_PROFILE -eq 1 ]; then
              echo "✅ Profiles already installed by fastlane match, skipping manual installation"
              SKIP_MANUAL_INSTALL=1
            else
              echo "::warning::Profiles exist but none match com.fridgy.app, will try manual installation"
            fi
          fi
          
          # 只有在没有找到匹配的 profile 时才尝试手动安装
          if [ "${SKIP_MANUAL_INSTALL:-0}" -eq 0 ]; then
            # 尝试从 fastlane match 的 git 仓库手动复制 profiles
            echo "=========================================="
            echo "Attempting to manually install profiles from match repository..."
            echo "=========================================="
            
            # 获取 match git URL
            MATCH_GIT_URL=$(grep 'git_url' fastlane/Matchfile 2>/dev/null | sed 's/.*git_url("\(.*\)").*/\1/' || echo "")
            if [ -n "$MATCH_GIT_URL" ]; then
              echo "Match repository URL: $MATCH_GIT_URL"
              
              # fastlane match 通常将仓库克隆到 ~/.fastlane/match 或临时目录
              # 尝试查找 match 仓库的本地副本
              MATCH_REPO_PATHS=(
                "$HOME/.fastlane/match"
                "/tmp/match_repo"
                "$HOME/Library/Caches/match"
              )
              
              MATCH_REPO_FOUND=0
              for MATCH_REPO_PATH in "${MATCH_REPO_PATHS[@]}"; do
                if [ -d "$MATCH_REPO_PATH" ]; then
                  echo "Found potential match repository at: $MATCH_REPO_PATH"
                  # 查找 profiles 目录
                  if [ -d "$MATCH_REPO_PATH/profiles/appstore" ]; then
                    echo "Found profiles directory: $MATCH_REPO_PATH/profiles/appstore"
                    MATCH_REPO_FOUND=1
                    
                    # 查找 .mobileprovision 文件
                    PROFILE_FILES=$(find "$MATCH_REPO_PATH/profiles/appstore" -name "*.mobileprovision" -type f 2>/dev/null)
                    if [ -n "$PROFILE_FILES" ]; then
                      echo "Found profile files in match repository:"
                      echo "$PROFILE_FILES"
                      
                      # 复制每个 profile 到标准位置
                      echo "$PROFILE_FILES" | while read -r profile_file; do
                        if [ -f "$profile_file" ]; then
                          # 提取 profile UUID 作为文件名（使用临时文件）
                          TEMP_PLIST=$(mktemp)
                          security cms -D -i "$profile_file" > "$TEMP_PLIST" 2>/dev/null
                          if [ -s "$TEMP_PLIST" ]; then
                            PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
                            rm -f "$TEMP_PLIST"
                            
                            if [ -n "$PROFILE_UUID" ] && [ "$PROFILE_UUID" != "Error Reading File" ]; then
                              DEST_FILE="$PROFILE_DIR/${PROFILE_UUID}.mobileprovision"
                              echo "Copying profile to: $DEST_FILE"
                              cp "$profile_file" "$DEST_FILE"
                              chmod 644 "$DEST_FILE"
                              echo "✅ Installed profile: $PROFILE_UUID"
                            else
                              # 如果无法提取 UUID，使用原始文件名
                              FILENAME=$(basename "$profile_file")
                              DEST_FILE="$PROFILE_DIR/$FILENAME"
                              echo "Copying profile to: $DEST_FILE"
                              cp "$profile_file" "$DEST_FILE"
                              chmod 644 "$DEST_FILE"
                              echo "✅ Installed profile: $FILENAME"
                            fi
                          else
                            rm -f "$TEMP_PLIST"
                            # 如果无法解码，使用原始文件名
                            FILENAME=$(basename "$profile_file")
                            DEST_FILE="$PROFILE_DIR/$FILENAME"
                            echo "Copying profile to: $DEST_FILE"
                            cp "$profile_file" "$DEST_FILE"
                            chmod 644 "$DEST_FILE"
                            echo "✅ Installed profile: $FILENAME"
                          fi
                        fi
                      done
                    else
                      echo "No .mobileprovision files found in $MATCH_REPO_PATH/profiles/appstore"
                    fi
                    break
                  fi
                fi
              done
              
              if [ $MATCH_REPO_FOUND -eq 0 ]; then
                echo "::warning::Could not find match repository locally"
                echo "::warning::fastlane match may have cleaned up temporary files"
                echo "::warning::Will try to clone repository manually..."
                
                # 尝试手动克隆 match 仓库（如果需要）
                # 注意：这需要 MATCH_PASSWORD 和 MATCH_GIT_BASIC_AUTHORIZATION
                TEMP_MATCH_DIR=$(mktemp -d)
                echo "Cloning match repository to: $TEMP_MATCH_DIR"
                
                # 构建带认证的 URL
                if [ -n "$MATCH_GIT_BASIC_AUTHORIZATION" ]; then
                  # 解码 base64 或使用原始格式
                  if echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 -d > /dev/null 2>&1; then
                    AUTH_STRING=$(echo "$MATCH_GIT_BASIC_AUTHORIZATION" | base64 -d)
                  else
                    AUTH_STRING="$MATCH_GIT_BASIC_AUTHORIZATION"
                  fi
                  
                  if [[ "$MATCH_GIT_URL" == https://* ]] && [[ "$AUTH_STRING" == *":"* ]]; then
                    AUTH_USER=$(echo "$AUTH_STRING" | cut -d: -f1)
                    AUTH_TOKEN=$(echo "$AUTH_STRING" | cut -d: -f2-)
                    GIT_URL_WITH_AUTH=$(echo "$MATCH_GIT_URL" | sed "s|https://|https://$AUTH_USER:$AUTH_TOKEN@|")
                    
                    CLONE_OUTPUT=$(git clone "$GIT_URL_WITH_AUTH" "$TEMP_MATCH_DIR" 2>&1)
                    CLONE_EXIT_CODE=$?
                    
                    if [ $CLONE_EXIT_CODE -eq 0 ]; then
                      echo "✅ Successfully cloned match repository"
                      # 查找并复制 profiles
                      if [ -d "$TEMP_MATCH_DIR/profiles/appstore" ]; then
                        PROFILE_FILES=$(find "$TEMP_MATCH_DIR/profiles/appstore" -name "*.mobileprovision" -type f 2>/dev/null)
                        if [ -n "$PROFILE_FILES" ]; then
                          echo "Found profile files in cloned repository:"
                          echo "$PROFILE_FILES"
                          echo "$PROFILE_FILES" | while read -r profile_file; do
                            if [ -f "$profile_file" ]; then
                              # 提取 profile UUID（使用临时文件）
                              TEMP_PLIST=$(mktemp)
                              security cms -D -i "$profile_file" > "$TEMP_PLIST" 2>/dev/null
                              if [ -s "$TEMP_PLIST" ]; then
                                PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
                                rm -f "$TEMP_PLIST"
                                
                                if [ -n "$PROFILE_UUID" ] && [ "$PROFILE_UUID" != "Error Reading File" ]; then
                                  DEST_FILE="$PROFILE_DIR/${PROFILE_UUID}.mobileprovision"
                                  cp "$profile_file" "$DEST_FILE"
                                  chmod 644 "$DEST_FILE"
                                  echo "✅ Installed profile: $PROFILE_UUID"
                                else
                                  # 如果无法提取 UUID，使用原始文件名
                                  FILENAME=$(basename "$profile_file")
                                  DEST_FILE="$PROFILE_DIR/$FILENAME"
                                  cp "$profile_file" "$DEST_FILE"
                                  chmod 644 "$DEST_FILE"
                                  echo "✅ Installed profile: $FILENAME"
                                fi
                              else
                                rm -f "$TEMP_PLIST"
                                # 如果无法解码，使用原始文件名
                                FILENAME=$(basename "$profile_file")
                                DEST_FILE="$PROFILE_DIR/$FILENAME"
                                cp "$profile_file" "$DEST_FILE"
                                chmod 644 "$DEST_FILE"
                                echo "✅ Installed profile: $FILENAME"
                              fi
                            fi
                          done
                        else
                          echo "::warning::No .mobileprovision files found in cloned repository"
                        fi
                      else
                        echo "::warning::profiles/appstore directory not found in cloned repository"
                      fi
                      rm -rf "$TEMP_MATCH_DIR"
                    else
                      echo "::warning::Failed to clone match repository manually (exit code: $CLONE_EXIT_CODE)"
                      echo "Clone output:"
                      echo "$CLONE_OUTPUT" | head -20
                      rm -rf "$TEMP_MATCH_DIR"
                    fi
                  else
                    echo "::warning::Git URL is not HTTPS or authentication string format is invalid"
                  fi
                else
                  echo "::warning::MATCH_GIT_BASIC_AUTHORIZATION not set, cannot clone repository"
                fi
              fi
            fi
          else
            echo "Skipping manual profile installation (profiles already found)"
          fi
          
          echo "=========================================="
          echo "Final profile directory check..."
          echo "=========================================="
          echo "Listing all profiles in directory:"
          ls -la "$PROFILE_DIR" 2>/dev/null | head -20 || echo "Directory is empty or not accessible"
          
          # 查找匹配的 profile（包含 com.fridgy.app）
          PROFILE_FOUND=0
          NEED_FORCE_RECREATE=0
          
          for profile in "$PROFILE_DIR"/*.mobileprovision; do
            if [ -f "$profile" ]; then
              echo "Checking profile: $profile"
              # 使用临时文件来解码 profile
              TEMP_PLIST=$(mktemp)
              security cms -D -i "$profile" > "$TEMP_PLIST" 2>/dev/null
              
              if [ -s "$TEMP_PLIST" ]; then
                PROFILE_CONTENT=$(cat "$TEMP_PLIST")
                # 检查是否包含 com.fridgy.app
                if echo "$PROFILE_CONTENT" | grep -q "com.fridgy.app"; then
                  echo "✅ Found matching profile for com.fridgy.app: $profile"
                  PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
                  
                  if [ -n "$PROFILE_UUID" ] && [ "$PROFILE_UUID" != "Error Reading File" ]; then
                    PROFILE_FOUND=1
                    
                    # 检查是否包含 Push Notifications
                    if echo "$PROFILE_CONTENT" | grep -q "aps-environment"; then
                      echo "✅ Profile contains Push Notifications capability"
                      echo "Profile UUID: $PROFILE_UUID"
                      echo "profile_uuid=$PROFILE_UUID" >> $GITHUB_OUTPUT
                      rm -f "$TEMP_PLIST"
                      break
                    else
                      echo "::error::Profile does NOT contain Push Notifications capability"
                      echo "::error::Profile UUID: $PROFILE_UUID"
                      NEED_FORCE_RECREATE=1
                      rm -f "$TEMP_PLIST"
                      break
                    fi
                  else
                    echo "::warning::Could not extract UUID from profile"
                    rm -f "$TEMP_PLIST"
                  fi
                else
                  rm -f "$TEMP_PLIST"
                fi
              else
                echo "::warning::Could not decode profile: $profile"
                rm -f "$TEMP_PLIST"
              fi
            fi
          done
          
          # 如果找到 profile 但不包含 Push Notifications，强制重新创建
          if [ $PROFILE_FOUND -eq 1 ] && [ $NEED_FORCE_RECREATE -eq 1 ]; then
            echo "::error::Forcing fastlane match to recreate profile with Push Notifications..."
            fastlane match appstore --force 2>&1 | tee /tmp/match-force.log || {
              echo "::error::Failed to force recreate profile"
              tail -50 /tmp/match-force.log
              echo "::error::Please ensure Push Notifications is enabled in Apple Developer Portal"
              echo "::error::Visit: https://developer.apple.com/account/resources/identifiers/list"
              exit 1
            }
            # 重新查找 profile UUID
            echo "Re-scanning profiles after force recreation..."
            for profile in "$PROFILE_DIR"/*.mobileprovision; do
              if [ -f "$profile" ]; then
                PROFILE_CONTENT=$(security cms -D -i "$profile" 2>/dev/null)
                if [ -n "$PROFILE_CONTENT" ] && echo "$PROFILE_CONTENT" | grep -q "com.fridgy.app"; then
                  PROFILE_UUID=$(echo "$PROFILE_CONTENT" | /usr/libexec/PlistBuddy -c "Print :UUID" /dev/stdin 2>/dev/null || echo "")
                  if [ -n "$PROFILE_UUID" ]; then
                    echo "Found profile UUID after recreation: $PROFILE_UUID"
                    echo "profile_uuid=$PROFILE_UUID" >> $GITHUB_OUTPUT
                    if echo "$PROFILE_CONTENT" | grep -q "aps-environment"; then
                      echo "✅ Profile now contains Push Notifications capability"
                    else
                      echo "::error::Profile still does NOT contain Push Notifications after recreation"
                      echo "::error::Please check Apple Developer Portal settings"
                    fi
                    break
                  fi
                fi
              fi
            done
          fi
          
          if [ $PROFILE_FOUND -eq 0 ]; then
            echo "::error::"
            echo "::error::=========================================="
            echo "::error::CRITICAL: NO PROVISIONING PROFILE FOUND"
            echo "::error::=========================================="
            echo "::error::"
            echo "::error::No provisioning profile found for com.fridgy.app"
            echo "::error::This means fastlane match did not install the profile correctly"
            echo "::error::"
            echo "::error::Trying to list all profiles to debug:"
            find "$PROFILE_DIR" -name "*.mobileprovision" -type f 2>/dev/null | while read p; do
              echo "Profile file: $p"
              PROFILE_INFO=$(security cms -D -i "$p" 2>/dev/null)
              if [ -n "$PROFILE_INFO" ]; then
                echo "$PROFILE_INFO" | grep -E "(Name|UUID|application-identifier|aps-environment)" | head -10 || echo "Could not extract info"
              else
                echo "Could not decode"
              fi
            done
            
            echo "::error::"
            echo "::error::=========================================="
            echo "::error::MOST LIKELY CAUSE:"
            echo "::error::=========================================="
            echo "::error::Push Notifications is NOT enabled in Apple Developer Portal"
            echo "::error::"
            echo "::error::SOLUTION:"
            echo "::error::1. Visit: https://developer.apple.com/account/resources/identifiers/list"
            echo "::error::2. Click on 'Identifiers' in the left sidebar"
            echo "::error::3. Search for 'com.fridgy.app' or find it in the list"
            echo "::error::4. Click on the App ID to edit it"
            echo "::error::5. Scroll down to 'Capabilities' section"
            echo "::error::6. Enable 'Push Notifications' checkbox"
            echo "::error::7. Click 'Save' or 'Continue'"
            echo "::error::8. Wait a few minutes for changes to propagate"
            echo "::error::9. Re-run this GitHub Actions workflow"
            echo "::error::"
            echo "::error::After enabling Push Notifications, fastlane match will be able"
            echo "::error::to create a provisioning profile that includes this capability."
            echo "::error::"
            echo "::error::Cannot proceed without a valid provisioning profile. Exiting..."
            exit 1
          else
            echo "✅ Provisioning profile found and configured successfully"
          fi
          
          cd ..

      - name: Cache Xcode DerivedData
        uses: actions/cache@v4
        with:
          path: ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-xcode-${{ hashFiles('ios/Podfile.lock', 'ios/**/*.xcodeproj', 'ios/**/*.xcworkspace') }}
          restore-keys: |
            ${{ runner.os }}-xcode-

      - name: Build Archive
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          # 确保 build 目录存在
          mkdir -p build
          
          # 使用 xcodebuild 构建
          # fastlane match 已经配置好了证书和 profiles，使用手动签名
          echo "Starting archive build..."
          echo "Workspace: ios/Fridgy.xcworkspace"
          echo "Scheme: Fridgy"
          echo "Configuration: Release"
          echo "Archive Path: build/Fridgy.xcarchive"
          echo "Team ID: ${{ steps.get_team_id.outputs.team_id }}"
          
          # 使用 xcodebuild 构建
          # 如果找到了 provisioning profile UUID，明确指定它
          PROFILE_UUID="${{ steps.run_fastlane_match.outputs.profile_uuid }}"
          
          # 如果没有从步骤输出获取到 UUID，尝试再次查找
          if [ -z "$PROFILE_UUID" ]; then
            echo "::warning::No provisioning profile UUID from fastlane match step, trying to find it manually..."
            # fastlane match 将 profiles 安装到 Xcode 目录
            XCODE_PROFILE_DIR="$HOME/Library/Developer/Xcode/UserData/Provisioning Profiles"
            MOBILEDEVICE_PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
            
            # 优先检查 Xcode profile 目录
            PROFILE_DIR=""
            if [ -d "$XCODE_PROFILE_DIR" ]; then
              PROFILE_DIR="$XCODE_PROFILE_DIR"
              echo "Checking Xcode profile directory: $PROFILE_DIR"
            elif [ -d "$MOBILEDEVICE_PROFILE_DIR" ]; then
              PROFILE_DIR="$MOBILEDEVICE_PROFILE_DIR"
              echo "Checking MobileDevice profile directory: $PROFILE_DIR"
            else
              echo "::error::Provisioning Profiles directories do not exist"
              echo "::error::Checked: $XCODE_PROFILE_DIR"
              echo "::error::Checked: $MOBILEDEVICE_PROFILE_DIR"
              echo "::error::This indicates fastlane match did not install any profiles"
              echo "::error::Please check the fastlane match step logs above for errors"
              exit 1
            fi
            
            echo "Searching for profiles in: $PROFILE_DIR"
            PROFILE_COUNT=$(find "$PROFILE_DIR" -name "*.mobileprovision" -type f 2>/dev/null | wc -l | tr -d ' ')
            echo "Found $PROFILE_COUNT profile file(s) in directory"
            
            if [ "$PROFILE_COUNT" -eq 0 ]; then
              echo "::error::No provisioning profiles found in $PROFILE_DIR"
              echo "::error::This means fastlane match did not download/install any profiles"
              echo "::error::"
              echo "::error::Possible causes:"
              echo "::error::1. Push Notifications is not enabled in Apple Developer Portal"
              echo "::error::2. fastlane match failed to create/download the profile"
              echo "::error::3. API Key or authentication credentials are invalid"
              echo "::error::"
              echo "::error::Please check the fastlane match step logs above for detailed error messages"
              exit 1
            fi
            
            # 列出所有 profile 文件以便调试
            echo "Listing all profile files:"
            find "$PROFILE_DIR" -name "*.mobileprovision" -type f 2>/dev/null | head -10 | while read p; do
              echo "  - $p"
            done
            
            # 尝试查找匹配的 profile
            FOUND_PROFILE=0
            for profile in "$PROFILE_DIR"/*.mobileprovision; do
              if [ -f "$profile" ]; then
                # 使用临时文件来解码 profile
                TEMP_PLIST=$(mktemp)
                security cms -D -i "$profile" > "$TEMP_PLIST" 2>/dev/null
                
                if [ -s "$TEMP_PLIST" ]; then
                  PROFILE_CONTENT=$(cat "$TEMP_PLIST")
                  # 检查是否包含 com.fridgy.app
                  if echo "$PROFILE_CONTENT" | grep -q "com.fridgy.app"; then
                    echo "✅ Found matching profile for com.fridgy.app: $profile"
                    FOUND_PROFILE=1
                    
                    # 提取 UUID
                    PROFILE_UUID=$(/usr/libexec/PlistBuddy -c "Print :UUID" "$TEMP_PLIST" 2>/dev/null || echo "")
                    rm -f "$TEMP_PLIST"
                    if [ -n "$PROFILE_UUID" ]; then
                      echo "✅ Extracted profile UUID: $PROFILE_UUID"
                      
                      # 检查是否包含 Push Notifications
                      if echo "$PROFILE_CONTENT" | grep -q "aps-environment"; then
                        echo "✅ Profile contains Push Notifications capability"
                        break
                      else
                        echo "::error::Profile does NOT contain Push Notifications capability"
                        echo "::error::Profile UUID: $PROFILE_UUID"
                        echo "::error::Profile Name: $(echo "$PROFILE_CONTENT" | /usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin 2>/dev/null || echo "Unknown")"
                        echo "::error::"
                        echo "::error::SOLUTION:"
                        echo "::error::1. Visit: https://developer.apple.com/account/resources/identifiers/list"
                        echo "::error::2. Find 'com.fridgy.app' and click to edit"
                        echo "::error::3. Enable 'Push Notifications' in Capabilities section"
                        echo "::error::4. Save and wait a few minutes for changes to propagate"
                        echo "::error::5. Re-run this workflow (fastlane match will recreate the profile)"
                        exit 1
                      fi
                    else
                      echo "::warning::Could not extract UUID from profile: $profile"
                      # 尝试使用 plutil 作为备用方法
                      PROFILE_UUID=$(echo "$PROFILE_CONTENT" | plutil -extract UUID raw - 2>/dev/null || echo "")
                      if [ -n "$PROFILE_UUID" ]; then
                        echo "✅ Extracted UUID using plutil: $PROFILE_UUID"
                        if echo "$PROFILE_CONTENT" | grep -q "aps-environment"; then
                          echo "✅ Profile contains Push Notifications capability"
                          break
                        else
                          echo "::error::Profile does NOT contain Push Notifications capability"
                          exit 1
                        fi
                      fi
                    fi
                  fi
                else
                  echo "::warning::Could not decode profile: $profile"
                fi
              fi
            done
            
            if [ $FOUND_PROFILE -eq 0 ]; then
              echo "::error::"
              echo "::error::=========================================="
              echo "::error::NO MATCHING PROVISIONING PROFILE FOUND"
              echo "::error::=========================================="
              echo "::error::"
              echo "::error::Found $PROFILE_COUNT profile(s) but none match com.fridgy.app"
              echo "::error::"
              echo "::error::Debugging information:"
              echo "::error::Listing all profile identifiers found:"
              find "$PROFILE_DIR" -name "*.mobileprovision" -type f 2>/dev/null | head -5 | while read p; do
                PROFILE_INFO=$(security cms -D -i "$p" 2>/dev/null)
                if [ -n "$PROFILE_INFO" ]; then
                  APP_ID=$(echo "$PROFILE_INFO" | /usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" /dev/stdin 2>/dev/null || echo "Unknown")
                  PROFILE_NAME=$(echo "$PROFILE_INFO" | /usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin 2>/dev/null || echo "Unknown")
                  echo "::error::  - Profile: $PROFILE_NAME"
                  echo "::error::    App ID: $APP_ID"
                fi
              done
              echo "::error::"
              echo "::error::This usually means:"
              echo "::error::1. fastlane match created a profile for a different app identifier"
              echo "::error::2. The Matchfile configuration is incorrect"
              echo "::error::3. Push Notifications is not enabled, preventing profile creation"
              echo "::error::"
              echo "::error::Please check the Matchfile and ensure app_identifier is 'com.fridgy.app'"
              exit 1
            fi
            
            if [ -z "$PROFILE_UUID" ]; then
              echo "::error::"
              echo "::error::=========================================="
              echo "::error::FAILED TO EXTRACT PROFILE UUID"
              echo "::error::=========================================="
              echo "::error::"
              echo "::error::Found matching profile but could not extract UUID"
              echo "::error::This is unusual and may indicate a corrupted profile file"
              echo "::error::"
              echo "::error::Please try:"
              echo "::error::1. Re-run fastlane match to regenerate the profile"
              echo "::error::2. Check if Push Notifications is enabled in Apple Developer Portal"
              exit 1
            fi
          fi
          
          if [ -n "$PROFILE_UUID" ]; then
            echo "Using provisioning profile UUID: $PROFILE_UUID"
            
            # 清理可能卡住的进程
            echo "Checking for stuck processes..."
            pkill -9 codesign 2>/dev/null || true
            pkill -9 xcodebuild 2>/dev/null || true
            
            # 设置构建超时为 3 小时（10800 秒），避免在代码签名步骤卡住
            # 使用 Perl 的 alarm 功能实现超时（macOS 兼容）
            echo "Starting build with 3-hour timeout..."
            echo "Note: Code signing for Pods is disabled via Podfile post_install hook"
            perl -e 'alarm 10800; exec @ARGV' -- xcodebuild -workspace ios/Fridgy.xcworkspace \
              -scheme Fridgy \
              -configuration Release \
              -archivePath build/Fridgy.xcarchive \
              -derivedDataPath ~/Library/Developer/Xcode/DerivedData \
              -jobs $(sysctl -n hw.ncpu) \
              DEVELOPMENT_TEAM="${{ steps.get_team_id.outputs.team_id }}" \
              CODE_SIGN_STYLE="Manual" \
              CODE_SIGN_IDENTITY="Apple Distribution" \
              PROVISIONING_PROFILE_SPECIFIER="$PROFILE_UUID" \
              -allowProvisioningUpdates \
              archive 2>&1 | tee build.log || {
              EXIT_CODE=$?
              if [ $EXIT_CODE -eq 142 ]; then
                echo "::error::Build timed out after 3 hours. Likely stuck in code signing step."
                echo "::error::Checking for stuck processes..."
                ps aux | grep -E "(codesign|xcodebuild)" | head -20
                echo "::error::Last 100 lines of build log:"
                tail -100 build.log
                exit 1
              else
                exit $EXIT_CODE
              fi
            }
          else
            # 这不应该发生，因为上面的代码应该已经处理了所有情况并退出
            echo "::error::"
            echo "::error::=========================================="
            echo "::error::CRITICAL ERROR: NO PROFILE UUID"
            echo "::error::=========================================="
            echo "::error::"
            echo "::error::No provisioning profile UUID found for com.fridgy.app"
            echo "::error::This is a critical error that should have been caught earlier"
            echo "::error::"
            echo "::error::This usually means:"
            echo "::error::1. fastlane match did not install the profile correctly, OR"
            echo "::error::2. The profile does not contain Push Notifications capability"
            echo "::error::"
            echo "::error::Please check:"
            echo "::error::1. Ensure Push Notifications is enabled in Apple Developer Portal"
            echo "::error::   Visit: https://developer.apple.com/account/resources/identifiers/list"
            echo "::error::   Find com.fridgy.app and enable Push Notifications"
            echo "::error::2. Check the fastlane match step logs above for errors"
            echo "::error::3. Re-run this workflow after fixing the issue"
            echo "::error::"
            echo "::error::Cannot proceed without a valid provisioning profile UUID"
            exit 1
          fi
          
          BUILD_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "::error::Build failed with exit code $BUILD_EXIT_CODE"
            echo "Last 100 lines of build log:"
            tail -100 build.log
            exit 1
          fi
          
          # 验证 archive 是否创建成功
          if [ ! -d build/Fridgy.xcarchive ]; then
            echo "::error::Archive was not created despite build appearing to succeed"
            echo "Build log (last 50 lines):"
            tail -50 build.log
            exit 1
          fi
          
          echo "✅ Archive created successfully at build/Fridgy.xcarchive"
          echo "Archive size: $(du -sh build/Fridgy.xcarchive | cut -f1)"

      - name: Export IPA
        run: |
          # 检查 archive 是否存在
          if [ ! -d build/Fridgy.xcarchive ]; then
            echo "::error::Archive not found at build/Fridgy.xcarchive"
            echo "::error::The build step may have failed. Please check the Build Archive step logs."
            if [ -f build.log ]; then
              echo "Build log (last 50 lines):"
              tail -50 build.log
            fi
            exit 1
          fi
          
          echo "Archive found at build/Fridgy.xcarchive"
          
          # 检查 ExportOptions.plist 是否存在
          if [ ! -f ios/ExportOptions.plist ]; then
            echo "::error::ExportOptions.plist not found. Please create it from ExportOptions.plist.example"
            echo "::error::Make sure to replace YOUR_TEAM_ID with your actual Team ID"
            exit 1
          fi
          
          # 获取 Team ID（从之前的步骤）
          TEAM_ID="${{ steps.get_team_id.outputs.team_id }}"
          
          if [ -z "$TEAM_ID" ]; then
            echo "::error::Team ID not found. Please check the Get Team ID step."
            exit 1
          fi
          
          echo "Using Team ID: $TEAM_ID"
          
          # 自动替换 ExportOptions.plist 中的 YOUR_TEAM_ID（如果存在）
          # 只替换 <string>YOUR_TEAM_ID</string> 格式，不替换注释
          if grep -q "<string>YOUR_TEAM_ID</string>" ios/ExportOptions.plist; then
            echo "Replacing YOUR_TEAM_ID with actual Team ID..."
            # macOS sed 语法
            sed -i '' "s|<string>YOUR_TEAM_ID</string>|<string>$TEAM_ID</string>|g" ios/ExportOptions.plist
            echo "Team ID replaced successfully"
          fi
          
          # 验证 Team ID 已正确配置（检查实际的 teamID 值）
          ACTUAL_TEAM_ID=$(grep -A 1 '<key>teamID</key>' ios/ExportOptions.plist | grep '<string>' | sed -E 's/.*<string>([^<]*)<\/string>.*/\1/' | tr -d '[:space:]')
          
          if [ -z "$ACTUAL_TEAM_ID" ] || [ "$ACTUAL_TEAM_ID" = "YOUR_TEAM_ID" ]; then
            echo "::error::Team ID not properly configured in ios/ExportOptions.plist"
            echo "::error::Current value: '$ACTUAL_TEAM_ID'"
            echo "::error::Expected value: '$TEAM_ID'"
            echo "File content:"
            cat ios/ExportOptions.plist
            exit 1
          fi
          
          if [ "$ACTUAL_TEAM_ID" != "$TEAM_ID" ]; then
            echo "::warning::Team ID mismatch. Updating to match extracted Team ID..."
            # macOS sed 语法，使用备份文件然后删除
            sed -i.bak "s|<string>$ACTUAL_TEAM_ID</string>|<string>$TEAM_ID</string>|g" ios/ExportOptions.plist
            rm -f ios/ExportOptions.plist.bak
            echo "Team ID updated from '$ACTUAL_TEAM_ID' to '$TEAM_ID'"
          fi
          
          echo "ExportOptions.plist verified. Team ID: $ACTUAL_TEAM_ID"
          
          xcodebuild -exportArchive \
            -archivePath build/Fridgy.xcarchive \
            -exportPath build \
            -exportOptionsPlist ios/ExportOptions.plist \
            -allowProvisioningUpdates

      - name: Verify IPA file
        run: |
          if [ ! -f build/Fridgy.ipa ]; then
            echo "::error::IPA file not found after export"
            exit 1
          fi
          echo "IPA file size: $(du -h build/Fridgy.ipa | cut -f1)"

      - name: Upload to App Store Connect
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: build/Fridgy.ipa
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-${{ github.run_number }}
          path: build/Fridgy.ipa
          retention-days: 30

      - name: Build summary
        if: success()
        run: |
          echo "## 🍎 iOS Build Complete (GitHub Actions)" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Number**: $(grep -A 1 '"buildNumber"' app.json | tail -1 | sed 's/.*"\(.*\)".*/\1/')" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Type**: ${{ github.event.inputs.build_type || 'production' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ✅ Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Artifact**: ios-build-${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY

